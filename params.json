{"name":"Jrich","tagline":"These functions calculate the taxonomic measures presented in Posadas et al 2001 and in Miranda-Esquivel 2016.","body":"These functions calculate the taxonomic measures presented in Posadas et al 2001 and in Miranda-Esquivel 2016 to introduce Jack-knife re-sampling in evolutionary distinctiveness prioritization analysis. This analysis is a way to evaluate the support of the ranking of the areas to modifications in the data used, and therefore quantifying the persistence of a given area in a conservation analysis.\r\n\r\nFor further information, you could read http://link.springer.com/chapter/10.1007/978-3-319-22461-9_11\r\n\r\n\r\n\r\n> ###  **1.** An example with a single topology and distribution to reproduce Figure 1 in Miranda-Esquivel (2016)  \r\n\r\nFirst of all, we remove everything from the R environment.\r\n\r\n```{r}\r\n#\r\nrm(list=ls())\r\n\r\n```\r\n\r\nAnd close the graphic devices, if there is any.\r\n\r\n```{r}\r\n#\r\nif (dev.cur()!=1){dev.off()}\r\n\r\n```\r\n\r\nNow, we get the latest version of the library, from GitHub.\r\n\r\n```{r,eval=FALSE}\r\n\r\n#library(\"devtools\")\r\n\r\n#install_github(\"Dmirandae/jrich\")\r\n\r\n```\r\n\r\nWe load the library before proceeding.\r\n\r\n```{r}\r\n\r\nlibrary(jrich)\r\n\r\n```\r\n\r\nans set working directory to the R Data (make sure you have changed it to your own directory).\r\n\r\n```{r}\r\n\r\n# setwd(\"./myData/\")\r\n\r\n\r\n```\r\n\r\nNow, we can read a tree from `figure1.tre`, which is written in Newick format or we can use directly the tree from the data file.\r\n\r\n\r\nTo read a file form a file use:\r\n\r\n```{r, eval=FALSE}\r\n\r\n\r\ntree.figure1 <- read.tree (\"yourTree.tre\")\r\n\r\n```\r\n\r\nOr, upload the data set, using the `data` funtion.\r\n\r\n```{r}\r\n\r\n data(tree)\r\n\r\n```\r\n\r\nWe can plot the tree.\r\n\r\n```{r}\r\n\r\nplot(tree, main= \"Figure 1. Area Cladogram\")\r\n\r\n```\r\n\r\nWe can also read distributions using the species per area format. The distributions could be a csv file with several features: Each line has a species name and an area, and multiple areas for the same species means a widespread taxon in multiple lines.\r\n\r\nThe following function creates a data frame for the species distributions.\r\n\r\n```{r, eval=FALSE}\r\n\r\ndistrib.figure1 <- Read.Data(\"figure1.csv\")\r\n\r\nhead(distrib.figure1)\r\n\r\n```\r\n\r\n\r\nAlso, we could read the example distribution.\r\n\r\n```{r}\r\n\r\ndata(distribution)\r\n\r\n```\r\n\r\n\r\n\r\nWe run the initial Index calculation, with a verbose output.\r\n\r\n```{r}\r\nlibrary(jrich)\r\n\r\ninitial.Values <- Calculate.Index(tree=tree, distrib = distribution, verbose=T)\r\n\r\ninitial.Values \r\n\r\n```\r\n\r\nNote that the figures for __Is/Ws__ indices here are different from Figure 1 in Miranda-Esquivel 2016, as here are re-scaled to sum 1, but the proportions are exactly the same.\r\n\r\nTo obtain the same figures for __Is/Ws__ indices as in Figure 1, we must use this code: \r\n\r\n```{r}\r\n\r\nfigure1.Values <-  Calculate.Index(tree=tree, distrib = distribution, verbose=F, standard = \"tree\")\r\n\r\nfigure1.Values\r\n\r\nall.equal(initial.Values,figure1.Values)\r\n\r\n```\r\n\r\n**1.** Correlations between values\r\n\r\nPlot the initial Values for the index that \"explains\" the most with this line:\r\n\r\n```{r}\r\n\r\ncorrelations <- cor(initial.Values[,2:10],initial.Values[,2:10])\r\n\r\n```\r\n\r\nDo not forget using the following code to avoid the \"autocorrelation\".\r\n\r\n```{r}\r\n\r\ndiag(correlations) <- 0.0\r\n\r\n```\r\n\r\nNow we can determine the 'Best' descriptor:\r\n\r\n```{r}\r\n\r\nbest.Index <- which.max(apply(correlations,2,sum))\r\n\r\nbest.Index\r\n\r\n```\r\n\r\nWith the following instruction we can get the name of index that displays the highest value,\r\nand the row of the column __rich__ in which the object is found. \r\n\r\nKeep in mind that richness in not a good predictor for all indices. \r\n\r\n```{r}\r\n\r\nwhich(abs(correlations[,\"rich\"])==max(abs(correlations[,\"rich\"])))\r\n\r\n```\r\n \r\nTo plot aesthetic graphics, load the library `ggplot2`.\r\n \r\n```{r}\r\n\r\nlibrary(ggplot2)\r\n\r\n```\r\n\r\n**2.** The index that \"explains the most\", without resampling is:\r\n\r\n```{r}\r\n\r\nbest.Index <-   which.max(apply(correlations,2,sum))\r\n\r\nbest.Index\r\n\r\nqplot(initial.Values$area,initial.Values[,names(best.Index)], xlab = \"Areas\", \r\n      ylab =paste(names(best.Index),\" values\"), main = paste(\"Figure 2. Values of the most informative index: \",names(best.Index),\" Index\"))\r\n\r\n```\r\n\r\nIn this example, Areas __A / F / G / H__ have the same ranking, as area __A__ harbors species __I__, while areas __F / G / H__ have the highest absolute richness.\r\n\r\nWe run the analysis with a single Jackknife replicate with a jtip value of 0.5. \r\n\r\n```{r}\r\n\r\njack.Values <-  Calculate.Index(tree=tree, distrib = distribution,jtip = 0.5)\r\n\r\n```\r\n\r\nThe absolute difference between these two outputs can be computed with this instruction:\r\n\r\n```{r}\r\n\r\nall.equal(initial.Values, jack.Values)\r\n\r\n```\r\n\r\n**3.** But a single replicate is not interesting, therefore we can repeat the process 100 times, using two approaches:\r\n\r\n  + **3.1 **Jackknifing with a jtip value of 0.5, 100 replicates, using the `Calculate.Index` function.\r\n    \r\n```{r}\r\n\r\njack.Ranking.100 <- list()\r\nfor (i in 1:100){\r\n  ## if you want to get the output number replicate, uncomment this line:\r\n  ##print(paste(\"replicate #\",i), )\r\n  \r\n  jack.Ranking.100[[i]] <-  as.data.frame(Rank.Indices(Calculate.Index(tree=tree, distrib = distribution, verbose=FALSE,jtip = 0.5)))\r\n}\r\n\r\n```\r\n\r\n+ **3.2 **Comparing the whole ranking for the best index, 100 times.\r\n\r\n```{r}\r\n\r\ninitial.Ranking <-  as.data.frame(Rank.Indices(initial.Values))\r\n\r\njack.Ranking.100.comparison <- NULL\r\n\r\nfor (i in 1:100){\r\n  \r\n  if(!all(jack.Ranking.100[[i]][,best.Index] == \"X0X\")){\r\n    jack.Ranking.100.comparison[i] <- all.equal(initial.Ranking[,best.Index], \r\n                                                  jack.Ranking.100[[i]][,best.Index])  \r\n  }else jack.Ranking.100.comparison[i] <- 0\r\n}\r\n\r\n```\r\n\r\nGet the number of hits or the extent of the Jackknife replicate to recover the initial ranking:\r\n\r\n```{r}\r\n\r\nlength(which(jack.Ranking.100.comparison==TRUE))\r\n\r\n```\r\n\r\nTo estimate the error, we use this code:\r\n\r\n```{r}\r\n\r\nlength(which(as.data.frame(jack.Ranking.100.comparison)!=TRUE))\r\n\r\n```\r\n\r\nThese two figures indicate that the best index is not __I__. As it is also important to estimate the error, we can use the following code to compute it.\r\n\r\n```{r}\r\n\r\njack.Mismatch <- jack.Ranking.100.comparison[jack.Ranking.100.comparison!=TRUE]\r\n\r\ncount.Jack.Mismatch <- gsub(\" string mismatches\",\"\",jack.Mismatch)\r\n\r\ncount.Jack.Mismatch <- as.numeric(count.Jack.Mismatch) \r\n\r\n```\r\n\r\nPlot the distribution of the error, not so bell-shaped.\r\n\r\n```{r}\r\n\r\nhist(sort(count.Jack.Mismatch,na.last = NA), main = \"Figure 3. Histogram of Error Distribution\", xlab= \"Jack Mistmatch count\")\r\n\r\n```\r\n\r\n**4.** A wrap to theprevious function, and evaluating the number of times we recovered 1/2/3 position in the ranking.\r\n\r\nNote that `Calculate.Index` recovers the index values while `Best.Index` recovers the ranking comparison.\r\n\r\n```{r}\r\n\r\njack.figure1.jtip05.100replicates <- Best.Index(tree=tree, distrib = distribution, jtip = 0.5, replicates = 50, success = c(1:2))\r\n\r\njack.figure1.jtip05.100replicates\r\n\r\nbest.Index = names(jack.figure1.jtip05.100replicates)[c(which(jack.figure1.jtip05.100replicates == max(jack.figure1.jtip05.100replicates)))]\r\n```\r\n\r\n__W / Ws__ explains better than __I__, as they have a Jackknife value. In this context we can plot __Ws__.\r\n\r\n```{r}\r\nfor (i in 1:length(best.Index)){\r\n\r\nprint(best.Index[i])\r\n\r\nprint(qplot(initial.Values$area,initial.Values[,best.Index[i]], xlab = \"Areas\", \r\n      ylab =paste(best.Index[i],\" values\"), main = paste(\"Figure 4. \",best.Index[i],\" Index\")))\r\n}\r\n```\r\n\r\nAs it is shown in __Figure 4.__, areas __F/G/H__ have a higher value as they have higher richness, but even so, the support is relatively low.\r\n\r\n> ###  **2.** An example with two topologies and distributions  \r\n\r\nFor this example, We will work with a tree and a distribution for an real taxon: _Puranius_ (These two files could be found in in the data directory). \r\n\r\n```{r, eval=FALSE}\r\n\r\ntree.Puranius <- read.tree (\"puranius.tre\")\r\n\r\ndistrib.Puranius <- Read.Data (\"puranius.csv.gz\")\r\n\r\n```\r\n\r\nNow we will assign a list to the object `data.Puranius` in order to join the tree and the distribution, which could certainly be made with a function as well. However, I prefer this approach. \r\n\r\n```{r, eval=FALSE}\r\n\r\ndata.Puranius  <- list()\r\n\r\ndata.Puranius[[1]] <- tree.Puranius \r\n\r\ndata.Puranius[[2]] <- distrib.Puranius\r\n\r\nhead(data.Puranius)\r\n\r\n```\r\n\r\nWe will proceed just as we did for the first Taxon, thence we got a tree and a distribution for another Taxon: _Janus_.\r\n\r\n```{r, eval=FALSE}\r\n\r\ntree.Janus <- read.tree (\"Janus.tre\")\r\n\r\ndistrib.Janus <- Read.Data(\"Janus.csv.gz\")\r\n\r\ndata.Janus  <- list()\r\n\r\ndata.Janus[[1]] <- tree.Janus\r\n\r\ndata.Janus[[2]] <- distrib.Janus\r\n\r\ndata.Janus\r\n```\r\n\r\nThe following code creates a list to handle multiple datasets.\r\nIn this case, the list `Multitaxon1` contains two objects.\r\n\r\n```{r, eval=FALSE}\r\nMultitaxon1 <- list()\r\n\r\nMultitaxon1[[1]] <- data.Janus\r\n\r\nMultitaxon1[[2]] <- data.Puranius\r\n\r\n```\r\n\r\nThe function `Multi.Index.Calc` calculates indices values for a MultiData list. For this case, it computes the Initial ranking for `Multitaxon1` with default values. This action is performed just once.\r\n\r\n```{r}\r\n\r\ndata(Multitaxon1)\r\n\r\ninitial.Values.Multi <-  Multi.Index.Calc(Multitaxon1)\r\n\r\n```\r\n\r\nBefore plotting the initial Values for the Index that explains the most, make sure that the library `ggplot2` is loaded.\r\n\r\n```{r}\r\nlibrary(ggplot2)\r\n```\r\n\r\n**1.** Correlations between values\r\n\r\nPlotting as example, the index value that explains the most is:\r\n\r\n```{r}\r\ncorrelations.Multi <-  cor(initial.Values.Multi[,2:10], initial.Values.Multi[,2:10])\r\n```\r\n\r\nTo avoid the highest \"autocorrelation\", use this line:\r\n\r\n```{r}\r\ndiag(correlations.Multi) <- 0.0\r\n```\r\n\r\nIn case we want to know the index that explains the most, use this code:\r\n\r\n```{r}\r\nbest.Index.Multi <-   which.max(apply(correlations.Multi,2,sum))\r\n\r\nqplot(initial.Values.Multi$area,initial.Values.Multi[,names(best.Index.Multi)], xlab = \"Areas\", ylab =names(best.Index.Multi), main = \"Figure 5. Values of the Index that explains the most per area\")\r\n```\r\n\r\n> **2.** A  delete experiment: Prob jtip jtopol 0.5 \r\n\r\n```{r}\r\njack.Multi <-  Multi.Index.Calc(Multitaxon1,jtip = 0.5,jtopol = 0.5) \r\n```\r\n\r\nSee that the `jtopol` and `jtip` present the deleted proportions, and the two data frames are different.\r\n\r\n```{r}\r\nall.equal(jack.Multi,initial.Values.Multi)\r\n\r\nvector <-   which.max(apply(correlations,2,sum))\r\n```\r\n\r\n**3.** Jack Ranking Multitaxon 100 times\r\n\r\nThis operation computes the index values and returns a data matrix. Diverse from the first method, it allows to perform this operation 100 times. The number of replicates can be easily modified, by changing the rank in for `(i in 1:100)`.\r\n\r\n```{r}\r\n\r\njack.Ranking.100 <- list()\r\n\r\nfor (i in 1:100){\r\n  print(paste(\"replicate #\",i))\r\n  jack.Ranking.100[[i]] <-  as.data.frame(Rank.Indices(Multi.Index.Calc(Multitaxon1,\r\n  jtip = 0.5,jtopol = 0.5)))\r\n}\r\n\r\n```\r\n\r\nWe can get the ranking in the first run. It is only necessary to run this line:\r\n\r\n```{r}\r\n\r\njack.Ranking.100[[1]][,vector]\r\n\r\n```\r\n\r\n**4.** Convert the initial values to a ranking\r\n\r\nThe initial ranking for Multitaxon is assigned as follows:\r\n\r\n```{r}\r\ninitial.Ranking <-  as.data.frame(Rank.Indices(Multi.Index.Calc(Multitaxon1)))\r\n\r\n\r\ninitial.Ranking[,vector]\r\n```\r\n\r\n**5.** Compare the whole ranking for the best index, 100 times.\r\n\r\n```{r}\r\n\r\njack.Ranking.100.comparison <- NULL\r\n\r\nfor (i in 1:100){\r\n  jack.Ranking.100.comparison[i] <- all.equal(initial.Ranking[,vector], \r\n                                              jack.Ranking.100[[i]][,vector])\r\n}\r\n\r\n```\r\n\r\nCompute the number of hits or the Jackknife replicate ability to recover the initial ranking:\r\n\r\n```{r}\r\nlength(which(jack.Ranking.100.comparison==TRUE))\r\n```\r\n\r\nAs in the first example, get an estimation of the error.\r\n\r\n```{r}\r\n\r\nlength(which(as.data.frame(jack.Ranking.100.comparison)!=TRUE))\r\n\r\n```\r\n\r\nAnd with this instruction we can identify the type of error.\r\n\r\n```{r}\r\n\r\njack.Mismatch <- jack.Ranking.100.comparison[jack.Ranking.100.comparison!=TRUE]\r\n\r\ncount.Jack.Mismatch <- gsub(\" string mismatches\",\"\",jack.Mismatch)\r\n\r\ncount.Jack.Mismatch <- as.numeric(count.Jack.Mismatch) \r\n\r\n```\r\n\r\nThis code computes the distribution of the error, which will rather be bell shaped.\r\n\r\n```{r}\r\n\r\nhist(sort(count.Jack.Mismatch), main=\"Figure 6. Histogram of Error Distribution\",  xlab= \"Jack Mistmatch count\")\r\n\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}